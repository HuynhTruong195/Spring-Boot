1. 🌱 Spring Boot là gì?

Spring Boot là framework Java giúp bạn:

🚀 Tạo ứng dụng nhanh mà không cần cấu hình rườm rà.

🧩 Tích hợp sẵn các thư viện phổ biến (web, security, JPA...).

📦 Chạy độc lập (Tomcat/Jetty tích hợp).

📜 Convention over Configuration – có sẵn cấu hình hợp lý.

❌ Giảm XML config, dùng annotation + Java config.


Ví dụ: chỉ với @SpringBootApplication và vài dòng code là chạy được server web


Mục tiêu chính của Spring Boot:
Giảm cấu hình (Configuration): Không cần viết quá nhiều file cấu hình XML như trong Spring truyền thống
Tự động cấu hình (Auto Configuration): Dựa trên thư viện có trong classpath, Spring Boot sẽ tự đoán và cấu hình các thành phần cần thiết
Có sẵn server tích hợp: Spring Boot có thể chạy trực tiếp ứng dụng mà không cần deploy vào server ngoài như Tomcat
Tích hợp dễ dàng với Spring ecosystem: Spring Boot hoạt động mượt mà với Spring MVC, Spring Data, Spring Security, v.v



A. Cấu trúc dự án & lifecycle

Thư mục chuẩn:
    src/main/java   → code Java
    src/main/resources → file cấu hình (application.properties/yml)


Annotation khởi động:

@SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

Main method:

    SpringApplication.run(App.class, args);

B. Controller & Request Handling (trái tim của web app)

Annotation chính:

    @RestController – trả dữ liệu JSON

    @Controller – trả về HTML/JSP/Thymeleaf

    @GetMapping, @PostMapping – định nghĩa endpoint

    @RequestParam, @PathVariable – lấy dữ liệu từ URL/query

    Luồng xử lý: Request → DispatcherServlet → Controller → Service → Repository → DB



C. Dependency Injection (DI)

    Khái niệm: Spring tự tạo & inject đối tượng vào nơi cần dùng (IoC).

    Annotation chính:

    @Component, @Service, @Repository – khai báo Bean

    @Autowired – tiêm Bean

    Lợi ích: code tách biệt, dễ test, dễ mở rộng.

D. Làm việc với DB (Spring Data JPA)

    Entity: @Entity, @Id, @GeneratedValue

    Repository: extends JpaRepository<Entity, ID>

    Query method:

        List<User> findByName(String name);

    Cấu hình DB trong application.properties.



 E. Cấu hình & Profiles

application.properties / application.yml – lưu cấu hình.

Profiles (application-dev.properties, application-prod.properties) – đổi cấu hình theo môi trường.

@Value – lấy giá trị từ config.

F. Starter & Dependency Management

Starter là gói tiện ích sẵn sàng dùng (VD: spring-boot-starter-web, spring-boot-starter-data-jpa).

Quản lý dependencies qua Maven/Gradle.

G. Chạy & Deploy

Chạy bằng mvn spring-boot:run hoặc run class main.

Đóng gói .jar rồi chạy java -jar app.jar.



 
📜📜📜📜📜📜📜📜📜📜📜📜📜📜📜
Ví dụ một ứng dụng Spring Boot đơn giản:

    @SpringBootApplication
    public class MyApplication {
        public static void main (String[] args){
            SpringApplication.run(MyApplication.class, args);
        }
    }

@SpringBootApplication là một annotation bao gồm:
@Configuration
@EnableAutoConfiguration
@ComponentScan


🌟 Những tính năng nổi bật của Spring Boot
1. ⚡ Khởi tạo nhanh & Tích hợp sẵn

Auto Configuration 🛠 – Tự động cấu hình dựa trên thư viện bạn thêm vào.

Starter POMs 📦 – Gói tiện ích có sẵn (web, JPA, security, mail, batch…).

Embedded Server 🌐 – Tích hợp sẵn Tomcat/Jetty/Undertow, chạy app như java -jar.

2. 📜 Giảm cấu hình phức tạp

Ít hoặc không cần XML – gần như tất cả cấu hình dùng annotation & Java config.

Convention over Configuration – Có cấu hình mặc định hợp lý, chỉ chỉnh khi cần.

3. 🔌 Dependency Injection mạnh mẽ

Hỗ trợ đầy đủ DI & IoC của Spring.

Tích hợp annotation như @Component, @Service, @Repository, @Autowired.

4. 🗄 Tích hợp Database dễ dàng

Hỗ trợ Spring Data JPA, JDBC, MyBatis…

Quản lý kết nối DB dễ dàng qua application.properties.

Chạy script SQL tự động khi app start.

5. ⚙️ Profiles & Config linh hoạt

Profiles 🧩 – Tách cấu hình theo môi trường (dev/test/prod).

Hỗ trợ application.properties & application.yml.

Externalized Configuration – dễ đổi config mà không cần build lại app.

6. 📊 Actuator – Giám sát & Quản lý

Spring Boot Actuator 📈 – Cung cấp endpoint để theo dõi sức khỏe ứng dụng, metrics, logs…

Dễ tích hợp với Prometheus, Grafana.

7. 🧪 Testing tiện lợi

Hỗ trợ JUnit, Mockito, Spring Test.

Có annotation như @SpringBootTest để test toàn bộ app.

8. 🚀 Deploy đa dạng

Build thành .jar hoặc .war.

Deploy được trên mọi nền tảng (server vật lý, cloud, container như Docker/Kubernetes).



Tự động cấu hình (Auto Configuration)
Spring Boot tự động cấu hình các thành phần của ứng dụng dựa trên thư viện có trong classpath và cấu hình mặc định hợp lý
Ví dụ:
Nếu bạn thêm spring-boot-starter-web, Spring Boot sẽ tự động cấu hình Spring MVC và Tomcat
Nếu có spring-boot-starter-data-jpa, Spring Boot sẽ cấu hình JPA và kết nối cơ sở dữ liệu



Starter Dependencies
Spring Boot cung cấp các gói starter để gom nhóm các thư viện thường dùng lại với nhau, ví dụ:
 

Starter             	              Chức năng
spring-boot-starter-web          Phát triển web REST/API với Spring MVC
spring-boot-starter-data-jpa       Làm việc với JPA và Hibernate
spring-boot-starter-security        Bảo mật ứng dụng
spring-boot-starter-test            Viết test đơn vị, mock, integration test


Tích hợp server nhúng
    Spring Boot hỗ trợ server nhúng (embedded) như:
    Tomcat (mặc định)
    Jetty
    Undertow
 

Spring Boot Actuator
Spring Boot Actuator cung cấp nhiều endpoint tiện ích để giám sát và kiểm tra tình trạng hệ thống:

Endpoint            Chức năng
/actuator/health    Kiểm tra trạng thái hệ thống
/actuator/metrics   Xem thông tin về CPU, RAM, request
/actuator/env       Xem các biến môi trường và cấu hình
/actuator/loggers   Theo dõi cấu hình log hiện tại      

 

Hỗ trợ cấu hình linh hoạt
    Spring Boot hỗ trợ 2 định dạng cấu hình:
    application.properties
    application.yml
    Ngoài ra, hỗ trợ nhiều profile môi trường (dev, test, prod) giúp tùy biến cấu hình cho từng môi trường chạy
    

Tích hợp công cụ test mạnh mẽ
    Spring Boot tích hợp sẵn các công cụ test như:
    JUnit
    Mockito
    Spring Test
    TestRestTemplate (test REST API)
    @SpringBootTest (chạy context đầy đủ)
    Giúp viết test dễ hơn, nhanh hơn và đáng tin cậy hơn


Spring Initializr – Tạo project siêu nhanh
    Spring Boot cung cấp website https://start.spring.io để:
    Chọn phiên bản Spring Boot
    Chọn các starter cần thiết
    Tạo project và tải về file ZIP
    Cực kỳ tiện lợi để khởi đầu dự án mới


Dễ mở rộng – phù hợp Microservices
    Spring Boot được thiết kế sẵn để:
    Tương thích với kiến trúc Microservices
    Hỗ trợ Docker, cloud (Heroku, AWS, GCP)
    Dễ tích hợp với Spring Cloud, Kafka, RabbitMQ...    
  
    

💾💾💾💾💾💾💾💾💾💾💾💾    
 CÁC DEPEDENCE TRONG SPRINGBOOT

 🌐 Spring Web

    Dependency: spring-boot-starter-web

    Dùng cho: Xây dựng ứng dụng web, REST API.

    Bao gồm: Spring MVC, Tomcat (mặc định), Jackson (JSON).

    Ví dụ: @RestController, @GetMapping, @PostMapping.

🗄 Spring Data JPA

    Dependency: spring-boot-starter-data-jpa

    Dùng cho: Kết nối cơ sở dữ liệu, ORM với Hibernate.

    Bao gồm: Hibernate, JPA API.

    Ví dụ: @Entity, @Repository, findAll(), save().

💾 Database Driver

    Ví dụ: mysql-connector-java (MySQL), postgresql (PostgreSQL).

    Dùng cho: Cho phép Spring Boot kết nối trực tiếp đến cơ sở dữ liệu tương ứng.

🔐 Spring Security

    Dependency: spring-boot-starter-security

    Dùng cho: Quản lý xác thực (authentication) và phân quyền (authorization).

    Ví dụ: @EnableWebSecurity, cấu hình UserDetailsService.

📝 Spring Boot DevTools

    Dependency: spring-boot-devtools

    Dùng cho: Hỗ trợ phát triển nhanh: tự động reload khi thay đổi code.

📦 Spring Boot Starter Test

    Dependency: spring-boot-starter-test

    Dùng cho: Viết unit test và integration test.

    Bao gồm: JUnit, Mockito, Spring Test.



spring-boot-starter-web

    Xây dựng ứng dụng web RESTful với Spring MVC

spring-boot-starter-data-jpa

    Kết nối CSDL và thao tác ORM với JPA + Hibernate

spring-boot-starter-security

    Cung cấp bảo mật (xác thực, phân quyền)

spring-boot-starter-thymeleaf

    Sử dụng Thymeleaf để tạo giao diện HTML

spring-boot-starter-test

    Viết unit test và integration test (JUnit, Mockito, AssertJ)

spring-boot-starter-validation

    Hỗ trợ validation (JSR-380) cho dữ liệu đầu vào

spring-boot-starter-mail

    Gửi email từ ứng dụng

spring-boot-starter-actuator

    Giám sát hệ thống, kiểm tra health, metrics, logs

 

Quản lý dependency bằng Maven/Gradle
Với Maven:
    Bạn khai báo dependencies trong file pom.xml
Maven sẽ tự động tải các thư viện liên quan về project của bạn
Với Gradle:
    Tương tự, nhưng khai báo trong file build.gradle    






💾💾💾💾💾💾💾💾💾💾💾💾 💾💾💾💾💾💾💾💾💾💾💾💾 

    Spring Data JPA

🔑 Điểm chính:
 Spring Data JPA là một module trong hệ sinh thái Spring Data, được xây dựng trên nền JPA (Java Persistence API), giúp đơn giản hóa các thao tác với cơ sở dữ liệu
Nó không thay thế JPA, mà cung cấp thêm tầng trừu tượng cao hơn để giảm code boilerplate và tăng tốc phát triển


✅ Các thành phần liên quan
 JPA (chuẩn Java)
    API chuẩn để quản lý entity và ánh xạ object ↔ table
Hibernate
    Một trong những triển khai phổ biến nhất của JPA
Spring Data JPA
    Hỗ trợ tương tác với JPA dễ dàng hơn qua Repository

✅ Lợi ích của Spring Data JPA
    Không cần viết SQL cho các truy vấn đơn giản
    Tự sinh các hàm như save(), findById(), findAll()
    Hỗ trợ phân trang, sắp xếp, query động
    Tích hợp dễ dàng với Spring Boot

💡 Ví dụ:

@Entity
public class User{
    @Id
    @GeneratedValue
    private Long id;
    
    private String username;
    private String email;
}
#Repository
    public interface UserRepository extends JpaRepository<User, Long> {
        List<User> findByName(String name);
    }
👉 Chỉ cần kế thừa JpaRepository, bạn đã có sẵn đầy đủ các phương thức CRUD


✅ Các interface quan trọng
CrudRepository<T, ID>
    Các hàm cơ bản: save, findById, delete

PagingAndSortingRepository<T, ID>
    Hỗ trợ thêm phân trang và sắp xếp

JpaRepository<T, ID>
    Mở rộng cả hai interface trên + thêm các hàm tiện ích khác

JpaSpecificationExecutor<T>
    Hỗ trợ viết query động theo điều kiện (Specification)

⚙️ Cơ chế sinh truy vấn tự động
Khi bạn viết một method trong Repository, Spring sẽ đọc tên method rồi dịch sang query SQL/JPQL.
Ví dụ:
    List<User> findByName(String name);
Spring sẽ tự hiểu là: SELECT u FROM User u WHERE u.name = :name

✅Quy tắc đặt tên (Method Name Keywords)
Một số từ khóa đặc biệt trong tên method sẽ được Spring hiểu để sinh query:

    findBy, readBy, getBy → tìm kiếm

    And, Or → nối nhiều điều kiện

    Between, LessThan, GreaterThan → so sánh

    Like, Containing, StartingWith, EndingWith → tìm kiếm theo mẫu

    OrderBy → sắp xếp

👉 Ví dụ:    

    // Repository kế thừa JpaRepository
public interface UserRepository extends JpaRepository<User, Long> {

    // Spring sẽ tự sinh ra query: SELECT u FROM User u WHERE u.age > :age
    List<User> findByAgeGreaterThan(int age);

    // SELECT u FROM User u WHERE u.name LIKE %:keyword%
    List<User> findByNameContaining(String keyword);

    // SELECT u FROM User u WHERE u.name = :name OR u.email = :email
    List<User> findByNameOrEmail(String name, String email);
}

        
✅Custom query khi cần:
Nếu tên method không đáp ứng đủ, bạn có thể:
Dùng annotation @Query (JPQL hoặc native SQL).
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);


📝 Các cách viết truy vấn trong Spring Data JPA    

Method Name Query → ít code, chỉ cần đặt tên đúng quy tắc.

@Query → viết tay khi query phức tạp.

Specification → dùng khi filter nhiều điều kiện, build query động.

Projection → tối ưu khi không cần toàn bộ dữ liệu entity.

👉@Query (JPQL hoặc Native SQL)
public interface UserRepository extends JpaRepository<User, Long> {

    // JPQL (sử dụng tên entity và field, không phải tên bảng/column DB)
    @Query("SELECT u FROM User u WHERE u.email = :email")
    User findByEmailJPQL(@Param("email") String email);

    // Native SQL (viết đúng theo tên bảng và cột trong DB)
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    User findByEmailNative(@Param("email") String email);
}

. Specification (truy vấn động theo điều kiện)
// Tạo class chứa các điều kiện query động
public class UserSpecifications {

    // Điều kiện: tên bằng name
    public static Specification<User> hasName(String name) {
        // root: đại diện cho entity User
        // query: câu query tổng thể
        // cb: CriteriaBuilder để build điều kiện
        return (root, query, cb) -> cb.equal(root.get("name"), name);
    }

    // Điều kiện: tuổi lớn hơn age
    public static Specification<User> ageGreaterThan(int age) {
        return (root, query, cb) -> cb.greaterThan(root.get("age"), age);
    }
}

// Sử dụng trong Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
}

// Gọi trong Service
List<User> results = userRepository.findAll(
    Specification.where(UserSpecifications.hasName("Nam"))
                 .and(UserSpecifications.ageGreaterThan(20))
);


👉. Projection (trả về một phần dữ liệu)

// Interface projection: chỉ lấy ra 2 field (id và name)
public interface UserSummary {
    Long getId();   // lấy id
    String getName(); // lấy name
}

public interface UserRepository extends JpaRepository<User, Long> {

    // Spring sẽ chỉ map dữ liệu vào UserSummary, không lấy toàn bộ entity User
    List<UserSummary> findBy();
}

// Gọi ra chỉ nhận được dữ liệu gọn nhẹ hơn
for(UserSummary u : userRepository.findBy()) {
    System.out.println(u.getId() + " - " + u.getName());
}



📌Toán tử nối điều kiện



And

   👉 AND logic

Or

   👉 OR logic

Between

   👉 Trong khoảng

LessThan / GreaterThan

   👉 Nhỏ hơn / Lớn hơn

Like / Containing

   👉 Giống chuỗi / chứa chuỗi

IsNull / IsNotNull

   👉 Kiểm tra NULL hoặc không NULL

In

    👉Tồn tại trong danh sách

List<User> findByAgeGreaterThanAndStatus(Integer age, String status);
List<User> findyEmailContaining(String keyword);



📌Sắp xếp và phân trang

    Spring Data JPA hỗ trợ Sort và Pageable:
 List<User> findByStatus(String status, Sort sort);
 Page<User> findByRole(String role, Pageable pageable);



📌Một số ví dụ thực tế

List<Product> findByPriceBetween(BigDecimal min, BigDecimal max);
List<User> findByEmailLike(String emailPattern);
Optional<User> findByUsernameAndPassword(String username, String password);


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠

Custom Query với @Query

🔹 1. @Query với JPQL (Java Persistence Query Language)

    JPQL dùng tên entity và field trong class Java (không phải tên bảng/column trong DB).
    Giúp viết query độc lập với loại DB.

public interface UserRepository extends JpaRepository<User, Long> {

    // Lấy user theo email (dùng JPQL)
    @Query("SELECT u FROM User u WHERE u.email = :email")
    User findByEmail(@Param("email") String email);

    // Lấy user theo tên gần đúng (LIKE)
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> searchByName(@Param("name") String name);

    // Lấy user theo tuổi > ?1 (tham số theo vị trí)
    @Query("SELECT u FROM User u WHERE u.age > ?1")
    List<User> findOlderThan(int age);
}


🔹 2. @Query với Native SQL

    Dùng khi muốn viết SQL thuần theo đúng tên bảng/cột trong DB.
    Phù hợp cho query phức tạp, join nhiều bảng.

public interface UserRepository extends JpaRepository<User, Long> {

    // Native SQL: Lấy user theo email
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    User findByEmailNative(@Param("email") String email);

    // Native SQL: Lấy tất cả user có tuổi trong khoảng
    @Query(value = "SELECT * FROM users WHERE age BETWEEN :min AND :max", nativeQuery = true)
    List<User> findUsersBetweenAges(@Param("min") int min, @Param("max") int max);
}


🔹 3. @Query với Update/Delete

    Khi muốn cập nhật hoặc xóa dữ liệu, cần dùng @Modifying và @Transactional.

public interface UserRepository extends JpaRepository<User, Long> {

    // Cập nhật tên user theo id
    @Modifying
    @Transactional
    @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
    int updateUserName(@Param("id") Long id, @Param("name") String name);

    // Xóa user theo email
    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(@Param("email") String email);

    //tìm kiếm theo email
    @Query("SELECT Count(u)>0 FROM User u WHERE u.email= :email")
    Boolean existByEmail(@Param("mail") String mail)
    -> trả về true or false 
    . nếu lớn hơn 0 tức tồn tại-> true

    CÓ THỂ DÙNG THAM SỐ ?1, ?2

    @Query("SELECT COUNT(u) > 0 FROM User u WHERE u.email = ?1")
    Boolean existsByEmail(String email);

}


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
Paging và Sorting trong Spring Data JPA

1️⃣ Paging (Phân trang)

Trong Spring Data JPA, bạn có thể truyền vào tham số kiểu Pageable để lấy dữ liệu theo trang.

Ví dụ:
    public interface UserRepository extends JpaRepository<User, Long> {

        // Trả về Page<User> thay vì List<User>
        Page<User> findByAgeGreaterThan(int age, Pageable pageable);
    }


Sử dụng trong Service/Controller:
   // Page số 0 (trang đầu), size = 5 tức có 5 phần tử 1 trang
Pageable pageable = PageRequest.of(0, 5);

// Gọi repo -> trả về 5 User có age > 18
Page<User> page = userRepository.findByAgeGreaterThan(18, pageable);

// Lấy dữ liệu
List<User> users = page.getContent();   ->danh sách dữ liệu
int totalPages = page.getTotalPages();  -> Tổng số trang
long totalElements = page.getTotalElements(); -> Tổng số phần tử
boolean hasNext = page.hasNext();       -> Còn trang sau hay không

👉 Pageable sẽ tự động sinh ra SQL có LIMIT và OFFSET.


2️⃣ Sorting (Sắp xếp)

Có thể sắp xếp bằng Sort hoặc kết hợp trong Pageable.

Ví dụ Sort riêng:
// Sắp xếp theo tên tăng dần
List<User> users = userRepository.findAll(Sort.by("name"));

// Sắp xếp theo tuổi giảm dần
List<User> users = userRepository.findAll(Sort.by(Sort.Direction.DESC, "age"));



3️⃣ Kết hợp Paging + Sorting

// Page số 0, size = 10, sắp xếp theo tuổi giảm dần
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "age"));

Page<User> page = userRepository.findAll(pageable);

👉 SQL sinh ra (ví dụ MySQL): 
SELECT * FROM users ORDER BY age DESC LIMIT 10 OFFSET 0;



4️⃣ Khi nào dùng Page vs Slice

Page<T>: có đầy đủ info (total elements, total pages, số trang hiện tại, …) → dùng khi bạn cần hiển thị phân trang chuẩn (ví dụ web show tổng số trang).

Slice<T>: chỉ biết có còn trang tiếp theo hay không (hasNext()) → nhẹ hơn, dùng khi chỉ cần load-more (infinite scroll).



🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
DTO Projection và Interface-based Projection

1️⃣ DTO Projection (Class-based Projection)
Khi bạn chỉ cần một phần dữ liệu của Entity (ví dụ: chỉ cần name và email thay vì toàn bộ User), bạn không nên tải toàn bộ entity. Lúc này, dùng Projection giúp:
    Truy vấn nhanh hơn
    Tránh lấy dữ liệu dư thừa
    Dễ map sang JSON hoặc dữ liệu trả về API

// DTO
public class UserDTO {
    private String name;
    private String email;

    public UserDTO(String name, String email) {  // constructor cần thiết
        this.name = name;
        this.email = email;
    }

    // getter và setter
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT new com.example.demo.UserDTO(u.name, u.email) FROM User u WHERE u.active = true")
    List<UserDTO> findActiveUsers();
}

Giải thích:

new com.example.demo.UserDTO(u.name, u.email) → Spring sẽ gọi constructor của DTO.

Chỉ lấy name và email, không load toàn bộ entity → tiết kiệm tài nguyên.

Hỗ trợ tính năng mạnh mẽ của class (constructor, method, validation...).


2️⃣ Interface-based Projection
Sử dụng interface để “map” dữ liệu từ query trực tiếp vào các getter method.
Spring Data JPA tự tạo implementation runtime, không cần DTO class thực sự.
Phù hợp với query đơn giản, không cần logic trong DTO.

Ví dụ:
    // Projection interface
    public interface UserNameEmail {
        String getName();
        String getEmail();
    }

    // Repository
    public interface UserRepository extends JpaRepository<User, Long> {

        List<UserNameEmail> findByActiveTrue();
    }

    LƯU Ý: Tên getter phải trùng với tên field trong Entity.

    Giải thích:

Spring tự generate class ẩn implementing UserNameEmail.

Khi query findByActiveTrue() → trả về list các object có getName() và getEmail().

Không cần constructor, không cần DTO class thực sự.
