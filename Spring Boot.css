1. 🌱 Spring Boot là gì?

Spring Boot là framework Java giúp bạn:

🚀 Tạo ứng dụng nhanh mà không cần cấu hình rườm rà.

🧩 Tích hợp sẵn các thư viện phổ biến (web, security, JPA...).

📦 Chạy độc lập (Tomcat/Jetty tích hợp).

📜 Convention over Configuration – có sẵn cấu hình hợp lý.

❌ Giảm XML config, dùng annotation + Java config.


Ví dụ: chỉ với @SpringBootApplication và vài dòng code là chạy được server web


Mục tiêu chính của Spring Boot:
Giảm cấu hình (Configuration): Không cần viết quá nhiều file cấu hình XML như trong Spring truyền thống
Tự động cấu hình (Auto Configuration): Dựa trên thư viện có trong classpath, Spring Boot sẽ tự đoán và cấu hình các thành phần cần thiết
Có sẵn server tích hợp: Spring Boot có thể chạy trực tiếp ứng dụng mà không cần deploy vào server ngoài như Tomcat
Tích hợp dễ dàng với Spring ecosystem: Spring Boot hoạt động mượt mà với Spring MVC, Spring Data, Spring Security, v.v



A. Cấu trúc dự án & lifecycle

Thư mục chuẩn:
    src/main/java   → code Java
    src/main/resources → file cấu hình (application.properties/yml)


Annotation khởi động:

@SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

Main method:

    SpringApplication.run(App.class, args);

B. Controller & Request Handling (trái tim của web app)

Annotation chính:

    @RestController – trả dữ liệu JSON

    @Controller – trả về HTML/JSP/Thymeleaf

    @GetMapping, @PostMapping – định nghĩa endpoint

    @RequestParam, @PathVariable – lấy dữ liệu từ URL/query

    Luồng xử lý: Request → DispatcherServlet → Controller → Service → Repository → DB



C. Dependency Injection (DI)

    Khái niệm: Spring tự tạo & inject đối tượng vào nơi cần dùng (IoC).

    Annotation chính:

    @Component, @Service, @Repository – khai báo Bean

    @Autowired – tiêm Bean

    Lợi ích: code tách biệt, dễ test, dễ mở rộng.

D. Làm việc với DB (Spring Data JPA)

    Entity: @Entity, @Id, @GeneratedValue

    Repository: extends JpaRepository<Entity, ID>

    Query method:

        List<User> findByName(String name);

    Cấu hình DB trong application.properties.



 E. Cấu hình & Profiles

application.properties / application.yml – lưu cấu hình.

Profiles (application-dev.properties, application-prod.properties) – đổi cấu hình theo môi trường.

@Value – lấy giá trị từ config.

F. Starter & Dependency Management

Starter là gói tiện ích sẵn sàng dùng (VD: spring-boot-starter-web, spring-boot-starter-data-jpa).

Quản lý dependencies qua Maven/Gradle.

G. Chạy & Deploy

Chạy bằng mvn spring-boot:run hoặc run class main.

Đóng gói .jar rồi chạy java -jar app.jar.



 
📜📜📜📜📜📜📜📜📜📜📜📜📜📜📜
Ví dụ một ứng dụng Spring Boot đơn giản:

    @SpringBootApplication
    public class MyApplication {
        public static void main (String[] args){
            SpringApplication.run(MyApplication.class, args);
        }
    }

@SpringBootApplication là một annotation bao gồm:
@Configuration
@EnableAutoConfiguration
@ComponentScan


🌟 Những tính năng nổi bật của Spring Boot
1. ⚡ Khởi tạo nhanh & Tích hợp sẵn

Auto Configuration 🛠 – Tự động cấu hình dựa trên thư viện bạn thêm vào.

Starter POMs 📦 – Gói tiện ích có sẵn (web, JPA, security, mail, batch…).

Embedded Server 🌐 – Tích hợp sẵn Tomcat/Jetty/Undertow, chạy app như java -jar.

2. 📜 Giảm cấu hình phức tạp

Ít hoặc không cần XML – gần như tất cả cấu hình dùng annotation & Java config.

Convention over Configuration – Có cấu hình mặc định hợp lý, chỉ chỉnh khi cần.

3. 🔌 Dependency Injection mạnh mẽ

Hỗ trợ đầy đủ DI & IoC của Spring.

Tích hợp annotation như @Component, @Service, @Repository, @Autowired.

4. 🗄 Tích hợp Database dễ dàng

Hỗ trợ Spring Data JPA, JDBC, MyBatis…

Quản lý kết nối DB dễ dàng qua application.properties.

Chạy script SQL tự động khi app start.

5. ⚙️ Profiles & Config linh hoạt

Profiles 🧩 – Tách cấu hình theo môi trường (dev/test/prod).

Hỗ trợ application.properties & application.yml.

Externalized Configuration – dễ đổi config mà không cần build lại app.

6. 📊 Actuator – Giám sát & Quản lý

Spring Boot Actuator 📈 – Cung cấp endpoint để theo dõi sức khỏe ứng dụng, metrics, logs…

Dễ tích hợp với Prometheus, Grafana.

7. 🧪 Testing tiện lợi

Hỗ trợ JUnit, Mockito, Spring Test.

Có annotation như @SpringBootTest để test toàn bộ app.

8. 🚀 Deploy đa dạng

Build thành .jar hoặc .war.

Deploy được trên mọi nền tảng (server vật lý, cloud, container như Docker/Kubernetes).



Tự động cấu hình (Auto Configuration)
Spring Boot tự động cấu hình các thành phần của ứng dụng dựa trên thư viện có trong classpath và cấu hình mặc định hợp lý
Ví dụ:
Nếu bạn thêm spring-boot-starter-web, Spring Boot sẽ tự động cấu hình Spring MVC và Tomcat
Nếu có spring-boot-starter-data-jpa, Spring Boot sẽ cấu hình JPA và kết nối cơ sở dữ liệu



Starter Dependencies
Spring Boot cung cấp các gói starter để gom nhóm các thư viện thường dùng lại với nhau, ví dụ:
 

Starter             	              Chức năng
spring-boot-starter-web          Phát triển web REST/API với Spring MVC
spring-boot-starter-data-jpa       Làm việc với JPA và Hibernate
spring-boot-starter-security        Bảo mật ứng dụng
spring-boot-starter-test            Viết test đơn vị, mock, integration test


Tích hợp server nhúng
    Spring Boot hỗ trợ server nhúng (embedded) như:
    Tomcat (mặc định)
    Jetty
    Undertow
 

Spring Boot Actuator
Spring Boot Actuator cung cấp nhiều endpoint tiện ích để giám sát và kiểm tra tình trạng hệ thống:

Endpoint            Chức năng
/actuator/health    Kiểm tra trạng thái hệ thống
/actuator/metrics   Xem thông tin về CPU, RAM, request
/actuator/env       Xem các biến môi trường và cấu hình
/actuator/loggers   Theo dõi cấu hình log hiện tại      

 

Hỗ trợ cấu hình linh hoạt
    Spring Boot hỗ trợ 2 định dạng cấu hình:
    application.properties
    application.yml
    Ngoài ra, hỗ trợ nhiều profile môi trường (dev, test, prod) giúp tùy biến cấu hình cho từng môi trường chạy
    

Tích hợp công cụ test mạnh mẽ
    Spring Boot tích hợp sẵn các công cụ test như:
    JUnit
    Mockito
    Spring Test
    TestRestTemplate (test REST API)
    @SpringBootTest (chạy context đầy đủ)
    Giúp viết test dễ hơn, nhanh hơn và đáng tin cậy hơn


Spring Initializr – Tạo project siêu nhanh
    Spring Boot cung cấp website https://start.spring.io để:
    Chọn phiên bản Spring Boot
    Chọn các starter cần thiết
    Tạo project và tải về file ZIP
    Cực kỳ tiện lợi để khởi đầu dự án mới


Dễ mở rộng – phù hợp Microservices
    Spring Boot được thiết kế sẵn để:
    Tương thích với kiến trúc Microservices
    Hỗ trợ Docker, cloud (Heroku, AWS, GCP)
    Dễ tích hợp với Spring Cloud, Kafka, RabbitMQ...    
  
    

💾💾💾💾💾💾💾💾💾💾💾💾    
 CÁC DEPEDENCE TRONG SPRINGBOOT

 🌐 Spring Web

    Dependency: spring-boot-starter-web

    Dùng cho: Xây dựng ứng dụng web, REST API.

    Bao gồm: Spring MVC, Tomcat (mặc định), Jackson (JSON).

    Ví dụ: @RestController, @GetMapping, @PostMapping.

🗄 Spring Data JPA

    Dependency: spring-boot-starter-data-jpa

    Dùng cho: Kết nối cơ sở dữ liệu, ORM với Hibernate.

    Bao gồm: Hibernate, JPA API.

    Ví dụ: @Entity, @Repository, findAll(), save().

💾 Database Driver

    Ví dụ: mysql-connector-java (MySQL), postgresql (PostgreSQL).

    Dùng cho: Cho phép Spring Boot kết nối trực tiếp đến cơ sở dữ liệu tương ứng.

🔐 Spring Security

    Dependency: spring-boot-starter-security

    Dùng cho: Quản lý xác thực (authentication) và phân quyền (authorization).

    Ví dụ: @EnableWebSecurity, cấu hình UserDetailsService.

📝 Spring Boot DevTools

    Dependency: spring-boot-devtools

    Dùng cho: Hỗ trợ phát triển nhanh: tự động reload khi thay đổi code.

📦 Spring Boot Starter Test

    Dependency: spring-boot-starter-test

    Dùng cho: Viết unit test và integration test.

    Bao gồm: JUnit, Mockito, Spring Test.



spring-boot-starter-web

    Xây dựng ứng dụng web RESTful với Spring MVC

spring-boot-starter-data-jpa

    Kết nối CSDL và thao tác ORM với JPA + Hibernate

spring-boot-starter-security

    Cung cấp bảo mật (xác thực, phân quyền)

spring-boot-starter-thymeleaf

    Sử dụng Thymeleaf để tạo giao diện HTML

spring-boot-starter-test

    Viết unit test và integration test (JUnit, Mockito, AssertJ)

spring-boot-starter-validation

    Hỗ trợ validation (JSR-380) cho dữ liệu đầu vào

spring-boot-starter-mail

    Gửi email từ ứng dụng

spring-boot-starter-actuator

    Giám sát hệ thống, kiểm tra health, metrics, logs

 

Quản lý dependency bằng Maven/Gradle
Với Maven:
    Bạn khai báo dependencies trong file pom.xml
Maven sẽ tự động tải các thư viện liên quan về project của bạn
Với Gradle:
    Tương tự, nhưng khai báo trong file build.gradle    






💾💾💾💾💾💾💾💾💾💾💾💾 💾💾💾💾💾💾💾💾💾💾💾💾 

    Spring Data JPA

🔑 Điểm chính:
 Spring Data JPA là một module trong hệ sinh thái Spring Data, được xây dựng trên nền JPA (Java Persistence API), giúp đơn giản hóa các thao tác với cơ sở dữ liệu
Nó không thay thế JPA, mà cung cấp thêm tầng trừu tượng cao hơn để giảm code boilerplate và tăng tốc phát triển


✅ Các thành phần liên quan
 JPA (chuẩn Java)
    API chuẩn để quản lý entity và ánh xạ object ↔ table
Hibernate
    Một trong những triển khai phổ biến nhất của JPA
Spring Data JPA
    Hỗ trợ tương tác với JPA dễ dàng hơn qua Repository

✅ Lợi ích của Spring Data JPA
    Không cần viết SQL cho các truy vấn đơn giản
    Tự sinh các hàm như save(), findById(), findAll()
    Hỗ trợ phân trang, sắp xếp, query động
    Tích hợp dễ dàng với Spring Boot

💡 Ví dụ:

@Entity
public class User{
    @Id
    @GeneratedValue
    private Long id;
    
    private String username;
    private String email;
}
#Repository
    public interface UserRepository extends JpaRepository<User, Long> {
        List<User> findByName(String name);
    }
👉 Chỉ cần kế thừa JpaRepository, bạn đã có sẵn đầy đủ các phương thức CRUD


✅ Các interface quan trọng
CrudRepository<T, ID>
    Các hàm cơ bản: save, findById, delete

PagingAndSortingRepository<T, ID>
    Hỗ trợ thêm phân trang và sắp xếp

JpaRepository<T, ID>
    Mở rộng cả hai interface trên + thêm các hàm tiện ích khác

JpaSpecificationExecutor<T>
    Hỗ trợ viết query động theo điều kiện (Specification)

⚙️ Cơ chế sinh truy vấn tự động
Khi bạn viết một method trong Repository, Spring sẽ đọc tên method rồi dịch sang query SQL/JPQL.
Ví dụ:
    List<User> findByName(String name);
Spring sẽ tự hiểu là: SELECT u FROM User u WHERE u.name = :name

✅Quy tắc đặt tên (Method Name Keywords)
Một số từ khóa đặc biệt trong tên method sẽ được Spring hiểu để sinh query:

    findBy, readBy, getBy → tìm kiếm

    And, Or → nối nhiều điều kiện

    Between, LessThan, GreaterThan → so sánh

    Like, Containing, StartingWith, EndingWith → tìm kiếm theo mẫu

    OrderBy → sắp xếp

👉 Ví dụ:    

    // Repository kế thừa JpaRepository
public interface UserRepository extends JpaRepository<User, Long> {

    // Spring sẽ tự sinh ra query: SELECT u FROM User u WHERE u.age > :age
    List<User> findByAgeGreaterThan(int age);

    // SELECT u FROM User u WHERE u.name LIKE %:keyword%
    List<User> findByNameContaining(String keyword);

    // SELECT u FROM User u WHERE u.name = :name OR u.email = :email
    List<User> findByNameOrEmail(String name, String email);
}

        
✅Custom query khi cần:
Nếu tên method không đáp ứng đủ, bạn có thể:
Dùng annotation @Query (JPQL hoặc native SQL).
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);


📝 Các cách viết truy vấn trong Spring Data JPA    

Method Name Query → ít code, chỉ cần đặt tên đúng quy tắc.

@Query → viết tay khi query phức tạp.

Specification → dùng khi filter nhiều điều kiện, build query động.

Projection → tối ưu khi không cần toàn bộ dữ liệu entity.

👉@Query (JPQL hoặc Native SQL)
public interface UserRepository extends JpaRepository<User, Long> {

    // JPQL (sử dụng tên entity và field, không phải tên bảng/column DB)
    @Query("SELECT u FROM User u WHERE u.email = :email")
    User findByEmailJPQL(@Param("email") String email);

    // Native SQL (viết đúng theo tên bảng và cột trong DB)
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    User findByEmailNative(@Param("email") String email);
}

. Specification (truy vấn động theo điều kiện)
// Tạo class chứa các điều kiện query động
public class UserSpecifications {

    // Điều kiện: tên bằng name
    public static Specification<User> hasName(String name) {
        // root: đại diện cho entity User
        // query: câu query tổng thể
        // cb: CriteriaBuilder để build điều kiện
        return (root, query, cb) -> cb.equal(root.get("name"), name);
    }

    // Điều kiện: tuổi lớn hơn age
    public static Specification<User> ageGreaterThan(int age) {
        return (root, query, cb) -> cb.greaterThan(root.get("age"), age);
    }
}

// Sử dụng trong Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
}

// Gọi trong Service
List<User> results = userRepository.findAll(
    Specification.where(UserSpecifications.hasName("Nam"))
                 .and(UserSpecifications.ageGreaterThan(20))
);


👉. Projection (trả về một phần dữ liệu)

// Interface projection: chỉ lấy ra 2 field (id và name)
public interface UserSummary {
    Long getId();   // lấy id
    String getName(); // lấy name
}

public interface UserRepository extends JpaRepository<User, Long> {

    // Spring sẽ chỉ map dữ liệu vào UserSummary, không lấy toàn bộ entity User
    List<UserSummary> findBy();
}

// Gọi ra chỉ nhận được dữ liệu gọn nhẹ hơn
for(UserSummary u : userRepository.findBy()) {
    System.out.println(u.getId() + " - " + u.getName());
}



📌Toán tử nối điều kiện



And

   👉 AND logic

Or

   👉 OR logic

Between

   👉 Trong khoảng

LessThan / GreaterThan

   👉 Nhỏ hơn / Lớn hơn

Like / Containing

   👉 Giống chuỗi / chứa chuỗi

IsNull / IsNotNull

   👉 Kiểm tra NULL hoặc không NULL

In

    👉Tồn tại trong danh sách

List<User> findByAgeGreaterThanAndStatus(Integer age, String status);
List<User> findyEmailContaining(String keyword);



📌Sắp xếp và phân trang

    Spring Data JPA hỗ trợ Sort và Pageable:
 List<User> findByStatus(String status, Sort sort);
 Page<User> findByRole(String role, Pageable pageable);



📌Một số ví dụ thực tế

List<Product> findByPriceBetween(BigDecimal min, BigDecimal max);
List<User> findByEmailLike(String emailPattern);
Optional<User> findByUsernameAndPassword(String username, String password);


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠

Custom Query với @Query

🔹 1. @Query với JPQL (Java Persistence Query Language)

    JPQL dùng tên entity và field trong class Java (không phải tên bảng/column trong DB).
    Giúp viết query độc lập với loại DB.

public interface UserRepository extends JpaRepository<User, Long> {

    // Lấy user theo email (dùng JPQL)
    @Query("SELECT u FROM User u WHERE u.email = :email")
    User findByEmail(@Param("email") String email);

    // Lấy user theo tên gần đúng (LIKE)
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> searchByName(@Param("name") String name);

    // Lấy user theo tuổi > ?1 (tham số theo vị trí)
    @Query("SELECT u FROM User u WHERE u.age > ?1")
    List<User> findOlderThan(int age);
}


🔹 2. @Query với Native SQL

    Dùng khi muốn viết SQL thuần theo đúng tên bảng/cột trong DB.
    Phù hợp cho query phức tạp, join nhiều bảng.

public interface UserRepository extends JpaRepository<User, Long> {

    // Native SQL: Lấy user theo email
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    User findByEmailNative(@Param("email") String email);

    // Native SQL: Lấy tất cả user có tuổi trong khoảng
    @Query(value = "SELECT * FROM users WHERE age BETWEEN :min AND :max", nativeQuery = true)
    List<User> findUsersBetweenAges(@Param("min") int min, @Param("max") int max);
}


🔹 3. @Query với Update/Delete

    Khi muốn cập nhật hoặc xóa dữ liệu, cần dùng @Modifying và @Transactional.

public interface UserRepository extends JpaRepository<User, Long> {

    // Cập nhật tên user theo id
    @Modifying
    @Transactional
    @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
    int updateUserName(@Param("id") Long id, @Param("name") String name);

    // Xóa user theo email
    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(@Param("email") String email);

    //tìm kiếm theo email
    @Query("SELECT Count(u)>0 FROM User u WHERE u.email= :email")
    Boolean existByEmail(@Param("mail") String mail)
    -> trả về true or false 
    . nếu lớn hơn 0 tức tồn tại-> true

    CÓ THỂ DÙNG THAM SỐ ?1, ?2

    @Query("SELECT COUNT(u) > 0 FROM User u WHERE u.email = ?1")
    Boolean existsByEmail(String email);

}


🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
Paging và Sorting trong Spring Data JPA

1️⃣ Paging (Phân trang)

Trong Spring Data JPA, bạn có thể truyền vào tham số kiểu Pageable để lấy dữ liệu theo trang.

Ví dụ:
    public interface UserRepository extends JpaRepository<User, Long> {

        // Trả về Page<User> thay vì List<User>
        Page<User> findByAgeGreaterThan(int age, Pageable pageable);
    }


Sử dụng trong Service/Controller:
   // Page số 0 (trang đầu), size = 5 tức có 5 phần tử 1 trang
Pageable pageable = PageRequest.of(0, 5);

// Gọi repo -> trả về 5 User có age > 18
Page<User> page = userRepository.findByAgeGreaterThan(18, pageable);

// Lấy dữ liệu
List<User> users = page.getContent();   ->danh sách dữ liệu
int totalPages = page.getTotalPages();  -> Tổng số trang
long totalElements = page.getTotalElements(); -> Tổng số phần tử
boolean hasNext = page.hasNext();       -> Còn trang sau hay không

👉 Pageable sẽ tự động sinh ra SQL có LIMIT và OFFSET.


2️⃣ Sorting (Sắp xếp)

Có thể sắp xếp bằng Sort hoặc kết hợp trong Pageable.

Ví dụ Sort riêng:
// Sắp xếp theo tên tăng dần
List<User> users = userRepository.findAll(Sort.by("name"));

// Sắp xếp theo tuổi giảm dần
List<User> users = userRepository.findAll(Sort.by(Sort.Direction.DESC, "age"));



3️⃣ Kết hợp Paging + Sorting

// Page số 0, size = 10, sắp xếp theo tuổi giảm dần
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "age"));

Page<User> page = userRepository.findAll(pageable);

👉 SQL sinh ra (ví dụ MySQL): 
SELECT * FROM users ORDER BY age DESC LIMIT 10 OFFSET 0;



4️⃣ Khi nào dùng Page vs Slice

Page<T>: có đầy đủ info (total elements, total pages, số trang hiện tại, …) → dùng khi bạn cần hiển thị phân trang chuẩn (ví dụ web show tổng số trang).

Slice<T>: chỉ biết có còn trang tiếp theo hay không (hasNext()) → nhẹ hơn, dùng khi chỉ cần load-more (infinite scroll).



🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
DTO Projection và Interface-based Projection

1️⃣ DTO Projection (Class-based Projection)
Khi bạn chỉ cần một phần dữ liệu của Entity (ví dụ: chỉ cần name và email thay vì toàn bộ User), bạn không nên tải toàn bộ entity. Lúc này, dùng Projection giúp:
    Truy vấn nhanh hơn
    Tránh lấy dữ liệu dư thừa
    Dễ map sang JSON hoặc dữ liệu trả về API

// DTO
public class UserDTO {
    private String name;
    private String email;

    public UserDTO(String name, String email) {  // constructor cần thiết
        this.name = name;
        this.email = email;
    }

    // getter và setter
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT new com.example.demo.UserDTO(u.name, u.email) FROM User u WHERE u.active = true")
    List<UserDTO> findActiveUsers();
}

Giải thích:

new com.example.demo.UserDTO(u.name, u.email) → Spring sẽ gọi constructor của DTO.

Chỉ lấy name và email, không load toàn bộ entity → tiết kiệm tài nguyên.

Hỗ trợ tính năng mạnh mẽ của class (constructor, method, validation...).


2️⃣ Interface-based Projection
Sử dụng interface để “map” dữ liệu từ query trực tiếp vào các getter method.
Spring Data JPA tự tạo implementation runtime, không cần DTO class thực sự.
Phù hợp với query đơn giản, không cần logic trong DTO.

Ví dụ:
    // Projection interface
    public interface UserNameEmail {
        String getName();
        String getEmail();
    }

    // Repository
    public interface UserRepository extends JpaRepository<User, Long> {

        List<UserNameEmail> findByActiveTrue();
    }

    LƯU Ý: Tên getter phải trùng với tên field trong Entity.

    Giải thích:

Spring tự generate class ẩn implementing UserNameEmail.

Khi query findByActiveTrue() → trả về list các object có getName() và getEmail().

Không cần constructor, không cần DTO class thực sự.


🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐

    Web Service là một dịch vụ chạy trên internet, cho phép các ứng dụng khác nhau 
    (có thể viết bằng ngôn ngữ khác nhau, chạy trên hệ điều hành khác nhau) 
    giao tiếp và trao đổi dữ liệu với nhau.

    Nó giống như một “cầu nối” giúp phần mềm này nói chuyện với phần mềm khác qua mạng.

🔑 Đặc điểm chính

    Giao tiếp qua Internet (thường qua HTTP/HTTPS).

    Ngôn ngữ lập trình không quan trọng → Java, .NET, Python… đều dùng chung được.

    Trao đổi dữ liệu chuẩn → thường dùng XML, JSON.

   Dễ tích hợp bên thứ ba (ví dụ: thanh toán qua Momo, ZaloPay, hoặc Google Maps API)   

🛠️ Các loại Web Service phổ biến

✅SOAP Web Service → dùng XML, chuẩn mực nhưng hơi phức tạp.
        SOAP (Simple Object Access Protocol)
        Dùng XML để trao đổi dữ liệu
        Có cấu trúc chặt chẽ, tuân thủ các tiêu chuẩn (WSDL, XML Schema, ...)
        Hơi nặng và phức tạp hơn REST
        Dùng nhiều trong môi trường doanh nghiệp (Enterprise)

✅RESTful Web Service (REST API) → dùng JSON, đơn giản, nhanh, hiện nay rất phổ biến.
        RESTful Web Service (Representational State Transfer)
        Sử dụng các phương thức HTTP: GET, POST, PUT, DELETE
        Dữ liệu thường trao đổi qua JSON hoặc XML
        Nhẹ, dễ xây dựng, dễ dùng
        Được dùng phổ biến hiện nay

✅Thành phần chính của một RESTful Web Service

URL/Endpoint

    Địa chỉ truy cập dịch vụ. VD: /api/users/1

HTTP Method

    Xác định hành động: GET, POST, PUT, DELETE

Request

    Dữ liệu gửi lên từ client

Response

    Dữ liệu trả về từ server (thường là JSON)

Status Code

    Mã phản hồi: 200 (OK), 404 (Not Found), 500 (Error), ... 
    
    
    
✅Web Service khác API chỗ nào?
    Web Service là một loại của API
    API (Application Programming Interface) là giao diện chung, có thể dùng không qua web (ví dụ: trong Java, C++)
    Web Service luôn hoạt động qua HTTP/HTTPS, còn API thì không nhất thiết

✅Các công nghệ thường dùng để tạo Web Service
    Java: Spring Boot (REST), JAX-RS (REST), JAX-WS (SOAP)
    .NET: ASP.NET Web API
    Node.js: Express
    Python: Flask, Django REST Framework
 

✅Ưu điểm của Web Service
    Giao tiếp đa nền tảng
    Dễ mở rộng, bảo trì
    Tái sử dụng dịch vụ
    Dễ tích hợp với bên ngoài
 

✅Nhược điểm
    Phụ thuộc vào kết nối mạng
    Bảo mật phức tạp hơn
    Độ trễ cao hơn so với gọi hàm nội bộ

⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️⚔️

⚔️ SOAP vs REST

🔹 SOAP (Simple Object Access Protocol)

    Định dạng dữ liệu: Chủ yếu dùng XML.

    Chuẩn mực, nghiêm ngặt (có quy tắc rõ ràng).

    Hỗ trợ bảo mật tốt (WS-Security, giao dịch...).

    Nặng hơn, phức tạp hơn → tốc độ chậm hơn.

    Thường dùng trong hệ thống lớn, tài chính, ngân hàng.

🔹 REST (Representational State Transfer)

    Định dạng dữ liệu: thường dùng JSON (nhẹ, dễ đọc), cũng có thể dùng XML.

    Đơn giản, linh hoạt, dễ học.

    Nhanh, nhẹ → phù hợp web và mobile.

    Chủ yếu dùng các HTTP method: GET, POST, PUT, DELETE.

    Được dùng rộng rãi hiện nay (API Facebook, Google, Zalo...).

📌 Tóm tắt dễ nhớ

    SOAP = nghiêm ngặt, phức tạp, dùng cho môi trường yêu cầu cao (ngân hàng, bảo mật).

    REST = đơn giản, nhanh, phổ biến, dùng nhiều trong web/mobile.

🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐
Nguyên lý hoạt động của RESTful API

REST là gì?
    REST (Representational State Transfer) là một kiến trúc phần mềm 
    dùng để thiết kế các dịch vụ web nhẹ, linh hoạt, đơn giản và hiệu quả – thường gọi là RESTful Web Services
 

RESTful API là gì?
    RESTful API là một giao diện lập trình ứng dụng tuân theo nguyên tắc REST, 
    cho phép các client (web, mobile, hệ thống khác) truy cập và thao tác tài nguyên trên server thông qua HTTP


📌Các nguyên lý chính của RESTful
🔹Stateless (Không trạng thái)
    Mỗi request từ client đến server độc lập, không lưu trạng thái
    Server không nhớ thông tin từ request trước đó
 

🔹Client – Server
    REST phân chia rõ giữa client và server
    Client không cần biết logic xử lý bên server
    Giúp tách biệt giao diện (frontend) và xử lý dữ liệu (backend)
    

🔹Uniform Interface (Giao diện đồng nhất)
    Sử dụng các phương thức HTTP tiêu chuẩn: GET, POST, PUT, DELETE
    Tài nguyên được định danh bằng URL
    Tất cả tài nguyên đều truy cập theo một kiểu nhất quán
    

🔹Resource-Based (Dựa trên tài nguyên)
    Mỗi tài nguyên (user, product, order,...) có một URL duy nhất
    Ví dụ: /api/products/1 đại diện cho sản phẩm có ID = 1
 

🔹Representation
    Tài nguyên có thể được đại diện dưới nhiều định dạng: JSON, XML (JSON phổ biến hơn)
    Client gửi request, server trả về đại diện (representation) của tài nguyên
 

🔹Cacheable
    Phản hồi từ server có thể được cache, giúp cải thiện hiệu suất
 

🌐 RESTful API hoạt động như thế nào?

    RESTful API hoạt động dựa trên giao thức HTTP (giống như khi bạn lướt web).

    Client (ứng dụng, website, mobile app) gửi request đến API.

    Server (nơi có dữ liệu/dịch vụ) nhận request → xử lý → trả về response (thường là JSON).

🔑 4 nguyên lý chính (CRUD qua HTTP method)

RESTful API gắn chức năng CRUD (Create, Read, Update, Delete) với HTTP methods:

HTTP        Method	Chức năng	        Ví dụ (URL = resource)
GET	        Lấy dữ liệu (Read)	        GET /users → lấy danh sách user
POST	Thêm dữ liệu mới (Create)	    POST /users → thêm user mới
PUT/PATCH	Cập nhật dữ liệu (Update)	    PUT /users/1 → sửa user có id=1
DELETE	    Xóa dữ liệu (Delete)	    DELETE /users/1 → xóa user có id=1

📌 Ví dụ minh họa

    Giả sử bạn có REST API quản lý user:

    GET /users → server trả danh sách user (JSON).

    GET /users/1 → server trả thông tin user có id = 1.

    POST /users (kèm dữ liệu JSON) → tạo user mới.

    PUT /users/1 → cập nhật user id=1.

    DELETE /users/1 → xóa user id=1.

👉 Tóm lại:
RESTful API = dùng URL để chỉ tài nguyên, HTTP method để thao tác, dữ liệu thường trả về JSON → đơn giản, nhanh, dễ tích hợp.    

🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️🏗️
TRONG MVC VÀ KHI VIẾT RESTful API

    🏗️ Controller “bình thường”

    @GetMapping("/users")
    public String getUsers(Model model) {
        // xử lý, trả về view (HTML, JSP, Thymeleaf...)
    }

    🌐 RESTful Controller

    Còn khi viết REST API, bạn thường dùng @RestController và các method GET, POST, PUT, DELETE để xử lý request.

    @RestController
    @RequestMapping("/users")
    public class UserController {

    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAll(); // trả JSON
    }

    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.save(user); // trả JSON
    }

    @PutMapping("/{id}")
    public User updateUser(@PathVariable int id, @RequestBody User user) {
        return userService.update(id, user); // trả JSON
    }

    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable int id) {
        userService.delete(id);
    }
}

👉 Ở đây:

    GET /users → lấy danh sách user

    POST /users → thêm user mới

    PUT /users/{id} → cập nhật user

    DELETE /users/{id} → xóa user

🔑 Các HTTP Methods trong RESTful API

GET

    📌 Mục đích: Lấy dữ liệu từ server.

    🛠️ Ví dụ: GET /users → lấy danh sách user.

    ✅ Đặc điểm: Không làm thay đổi dữ liệu (idempotent), có thể cache.

POST

    📌 Mục đích: Gửi dữ liệu mới lên server (tạo mới).

    🛠️ Ví dụ: POST /users (kèm JSON { "name": "Nam" }) → tạo user mới.

    ⚠️ Đặc điểm: Thay đổi dữ liệu, không idempotent (gửi 2 lần có thể tạo 2 bản ghi).

PUT

    📌 Mục đích: Cập nhật dữ liệu (thay thế toàn bộ).

    🛠️ Ví dụ: PUT /users/1 (kèm JSON) → cập nhật user có id=1.

    ✅ Đặc điểm: Idempotent (gửi nhiều lần kết quả vẫn như 1 lần).

DELETE

    📌 Mục đích: Xóa dữ liệu.

    🛠️ Ví dụ: DELETE /users/1 → xóa user id=1.

    ✅ Đặc điểm: Idempotent (xóa nhiều lần thì kết quả cuối cùng vẫn là đã xóa).

👉 Tóm lại dễ nhớ:

    GET = lấy dữ liệu

    POST = thêm mới

    PUT = cập nhật

    DELETE = xóa


    🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐🌐
🌐 JSON và XML trong RESTful API

Trong RESTful API, dữ liệu được trao đổi giữa client (ứng dụng, trình duyệt, mobile app) và server thông qua giao thức HTTP

Hai định dạng phổ biến nhất để biểu diễn dữ liệu là:

    JSON (JavaScript Object Notation)

    XML (eXtensible Markup Language)

🔹 JSON (JavaScript Object Notation)

    Dữ liệu dạng cặp key–value (giống object trong JS).

    Gọn, nhẹ, dễ đọc, dễ parse.

    Rất phổ biến trong RESTful API hiện nay.   
📌 Ví dụ:
    {
    "id": 1,
    "name": "Nam",
    "email": "nam@example.com"
    }

🔹 XML (eXtensible Markup Language)

    Dữ liệu dạng thẻ mở/đóng giống HTML.

    Nặng hơn, dài dòng hơn, nhưng có tính năng schema, namespace.

    Từng phổ biến, giờ ít dùng trong REST (chủ yếu trong SOAP).

📌 Ví dụ:
    <User>
        <id>1</id>
        <name>Nam</name>
        <email>nam@example.com</email>
    </User>

🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️🛠️

Các công cụ kiểm thử API (Postman, Swagger)

🛠️ 1. Postman

    Là ứng dụng chuyên để test API (REST, SOAP, GraphQL...).

    Cho phép bạn:

    Gửi request (GET, POST, PUT, DELETE…) đến API.

    Xem response (JSON, XML…).

    Lưu bộ sưu tập API để test lại sau.

    Tích hợp test tự động, tạo script kiểm thử.

    👉 Thường dùng khi dev muốn test API thủ công.

📌 Ví dụ: Bạn nhập URL http://localhost:8080/users, chọn method GET, nhấn Send → Postman sẽ trả về danh sách user ở dạng JSON.

🛠️ 2. Swagger (nay gọi là OpenAPI)

    Là bộ công cụ để mô tả và tài liệu hóa API.

    Tích hợp trực tiếp với code → tự động tạo tài liệu API.

    Giao diện web của Swagger cho phép:

    Xem danh sách tất cả các API (endpoint).

    Thấy rõ method (GET/POST/PUT/DELETE), input, output.

    Test API ngay trên giao diện mà không cần cài thêm gì.

    👉 Thường dùng để tài liệu hóa API cho team, cho client.

📌 Ví dụ: Bạn vào http://localhost:8080/swagger-ui.html → thấy ngay danh sách API /users, /products → bấm thử Try it out để test.


✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
HTTP Request và Response 

1. HTTP REQUEST (Yêu cầu từ Client)
🔹 Cấu trúc HTTP Request
    [METHOD] [URL] [HTTP_VERSION]
    [HEADERS]

    [BODY] (tùy chọn)
🔹 Các thành phần chính:
A. HTTP Methods (Phương thức)

Method      Mục đích        Có Body?         Ví dụ
GET         Lấy dữ liệu      ❌Không        Xem danh sách sản phẩm   
POST        Tạo mới            ✅ Có       Thêm sản phẩm mới
PUT         Cập nhật toàn bộ    ✅ Có       Sửa thông tin sản phẩm
PATCH       Cập nhật một phần   ✅ Có       Cập nhật giá sản phẩm
DELETE          Xóa             ❌ Không        Xóa sản phẩm

B. URL (Uniform Resource Locator)
https://api.example.com/products/123?category=electronics&sort=price
│       │               │        │   │
└─scheme └─host          └─path   └─query parameters

C. Headers (Tiêu đề)

    Chứa thông tin metadata về request

    httpContent-Type: application/json
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
    Accept: application/json
    User-Agent: Mozilla/5.0...

D. Body (Thân request)

Chứa dữ liệu gửi lên server (chỉ có ở POST, PUT, PATCH)

    {
        "name": "iPhone 15",
        "price": 999.99,
        "category": "electronics"
    }

🔹 Ví dụ HTTP Request hoàn chỉnh:
GET Request (Không có body):
    GET /api/products?category=electronics HTTP/1.1
    Host: api.example.com
    Accept: application/json
    Authorization: Bearer token123

POST Request (Có body):
    POST /api/products HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer token123

    {
        "name": "MacBook Pro",
        "price": 1999.99,
        "category": "computers"
    }



2. HTTP RESPONSE (Phản hồi từ Server)

🔹 Cấu trúc HTTP Response
    [HTTP_VERSION] [STATUS_CODE] [STATUS_TEXT]
    [HEADERS]

    [BODY] (tùy chọn)
🔹 Các thành phần chính:
A. Status Codes (Mã trạng thái)
Nhóm        Ý nghĩa     Ví dụ phổ biến
2xx     ✅ Thành công    200 OK,01 Created
3xx     🔄 Chuyển hướng     301 Moved Permanently
4xx     ❌ Lỗi từ Client        400 Bad Request, 404 Not Found
5xx     💥 Lỗi từ Server        500 Internal Server Error


Status codes quan trọng:

    200 OK: Thành công
    201 Created: Tạo mới thành công
    400 Bad Request: Dữ liệu không hợp lệ
    401 Unauthorized: Chưa đăng nhập
    403 Forbidden: Không có quyền truy cập
    404 Not Found: Không tìm thấy resource
    500 Internal Server Error: Lỗi server
